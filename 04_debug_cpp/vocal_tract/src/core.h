
// ==============================================================================
// 
// Copyright or © or Copr:
//     Antoine Falaize
// 
// Affiliation:
//     Team M2N (Mathematical and Numerical Methods),
//     Laboratoire des Sciences de l'Ingénieur pour l'Environnement (LaSIE),
//     UMR CNRS 7356, La Rochelle Université,
//     La Rochelle, France.
// 
// Contact:
//     antoine.falaize@univ-lr.fr
// 
// This file has been generated by the Python software PyPHS, which purpose
// is to model and simulate multiphysical systems in the Port-Hamiltonian
// formalism. See the website at the following url:
// "https://pyphs.github.io/pyphs/".
// 
// Created on:
//     2020/05/15 11:20:26
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// A copy of the GNU General Public License is available at the following url:
// "https://www.gnu.org/licenses/"
// 
// ==============================================================================

#ifndef VOCAL_TRACT_H
#define VOCAL_TRACT_H

#include <iostream>
#include <vector>
#include <cmath>
#include <Eigen/Dense>
#include "parameters.h"
#include <fstream>

    // new include ++++
    #include <Eigen/SparseCholesky>
    #include<Eigen/IterativeLinearSolvers>
    #include <Eigen/Sparse>
    typedef Eigen::SparseMatrix<double> SpMat; 


using namespace std;
using namespace Eigen;

class VOCAL_TRACT {
//==========================================================================
// PUBLIC    
    public:
    //==========================================================================
    // Sample Rate
    void set_sampleRate(float &);
    void set_sampleRate(double &);
    //==========================================================================
    // Core update
    void update();
    //==========================================================================
    // Acessors to Arguments, return vector<double>
    const vector<double> & x_vector() const;
    const vector<double> & dx_vector() const;
    const vector<double> & w_vector() const;
    const vector<double> & u_vector() const;
    const vector<double> & p_vector() const;
    const vector<double> & vnl_vector() const;
    const vector<double> & o_vector() const;
    //==========================================================================
    // Acessors to Arguments, return Matrix<double, n, m>
    const Matrix<double,36, 1> & x() const;
    const Matrix<double,36, 1> & dx() const;
    const Matrix<double,8, 1> & w() const;
    const Matrix<double,8, 1> & u() const;
    const Matrix<double,0, 0> & p() const;
    const Matrix<double,44, 1> & vnl() const;
    const Matrix<double,31, 1> & o() const;
    //==========================================================================
    // Mutators for Arguments, type = vector<double>
    void set_x(const vector<double> &);
    void set_dx(const vector<double> &);
    void set_w(const vector<double> &);
    void set_u(const vector<double> &);
    void set_p(const vector<double> &);
    void set_vnl(const vector<double> &);
    void set_o(const vector<double> &);
    //==========================================================================
    // Mutators for Arguments, type = Matrix<double, n, m>
    void set_x(const Matrix<double, 36, 1> &);
    void set_dx(const Matrix<double, 36, 1> &);
    void set_w(const Matrix<double, 8, 1> &);
    void set_u(const Matrix<double, 8, 1> &);
    void set_p(const Matrix<double, 0, 0> &);
    void set_vnl(const Matrix<double, 44, 1> &);
    void set_o(const Matrix<double, 31, 1> &);
    //==========================================================================
    // Mutators for a single argument, types are double with int index
    void set_x(const double &, unsigned int &);
    void set_dx(const double &, unsigned int &);
    void set_w(const double &, unsigned int &);
    void set_u(const double &, unsigned int &);
    void set_p(const double &, unsigned int &);
    void set_vnl(const double &, unsigned int &);
    void set_o(const double &, unsigned int &);
    //==========================================================================
    // Functions Results Accessors (matrix)
    const Matrix<double,31, 1> & ud_o() const;
    const Matrix<double,44, 1> & Gnl() const;
    const Matrix<double,44, 44> & jacGnlnl() const;
    const Matrix<double,36, 1> & dxH() const;
    const Matrix<double,8, 1> & z() const;
    const Matrix<double,8, 1> & y() const;
    //==========================================================================
    // Functions Results Accessors (vector)
    const vector<double> & ud_o_vector() const;
    const vector<double> & Gnl_vector() const;
    const vector<double> & jacGnlnl_vector() const;
    const vector<double> & dxH_vector() const;
    const vector<double> & z_vector() const;
    const vector<double> & y_vector() const;
    //==========================================================================
    // Functions Results Accessors (element)
    const double & ud_o(unsigned int &) const;
    const double & Gnl(unsigned int &) const;
    const double & jacGnlnl(unsigned int &) const;
    const double & dxH(unsigned int &) const;
    const double & z(unsigned int &) const;
    const double & y(unsigned int &) const;
    //==========================================================================
    // Oprations Results Accessors
    const Matrix<double,36, 1> & ud_x() const;
    const Matrix<double,44, 1> & Fnl() const;
    const Matrix<double,44, 44> & jacFnl() const;
    const Matrix<double,44, 44> & ijacFnl() const;
    const Matrix<double,44, 1> & save_Fnl() const;
    const double & res_Fnl() const;
    const double & step_Fnl() const;
    const Matrix<double,44, 1> & ud_vnl() const;
    //==========================================================================
    // Oprations Results Accessors
    vector<double> ud_x_vector() const;
    vector<double> Fnl_vector() const;
    vector<double> save_Fnl_vector() const;
    vector<double> ud_vnl_vector() const;
    //==========================================================================
    // Default Constructor
    VOCAL_TRACT();
    //==========================================================================
    // Default Destructor
    ~VOCAL_TRACT();

//==========================================================================
// PRIVATE    
    private:

    // Debug log file
    ofstream FID_log_Q22; 
    ofstream FID_log_shp; 
    //==========================================================================
    // Sample Rate
    double sampleRate = 1000000.0;
    const double * F_S = & sampleRate;
    //==========================================================================
    // Parameters
    const unsigned int indexParameters = 0;  // See file "parameters.cpp".
    const double * P_0 = & subs[indexParameters][0];
    const double * rho_0 = & subs[indexParameters][1];
    const double * gamma = & subs[indexParameters][2];
    const double * Z_ray = & subs[indexParameters][3];
    const double * ell_1 = & subs[indexParameters][4];
    const double * L_1 = & subs[indexParameters][5];
    const double * V_0_1 = & subs[indexParameters][6];
    const double * ell_2 = & subs[indexParameters][7];
    const double * L_2 = & subs[indexParameters][8];
    const double * V_0_2 = & subs[indexParameters][9];
    const double * ell_3 = & subs[indexParameters][10];
    const double * L_3 = & subs[indexParameters][11];
    const double * V_0_3 = & subs[indexParameters][12];
    const double * ell_4 = & subs[indexParameters][13];
    const double * L_4 = & subs[indexParameters][14];
    const double * V_0_4 = & subs[indexParameters][15];
    const double * ell_5 = & subs[indexParameters][16];
    const double * L_5 = & subs[indexParameters][17];
    const double * V_0_5 = & subs[indexParameters][18];
    const double * ell_6 = & subs[indexParameters][19];
    const double * L_6 = & subs[indexParameters][20];
    const double * V_0_6 = & subs[indexParameters][21];
    const double * ell_7 = & subs[indexParameters][22];
    const double * L_7 = & subs[indexParameters][23];
    const double * V_0_7 = & subs[indexParameters][24];
    const double * k_1 = & subs[indexParameters][25];
    const double * r_1 = & subs[indexParameters][26];
    const double * k_2 = & subs[indexParameters][27];
    const double * r_2 = & subs[indexParameters][28];
    const double * k_3 = & subs[indexParameters][29];
    const double * r_3 = & subs[indexParameters][30];
    const double * k_4 = & subs[indexParameters][31];
    const double * r_4 = & subs[indexParameters][32];
    const double * k_5 = & subs[indexParameters][33];
    const double * r_5 = & subs[indexParameters][34];
    const double * k_6 = & subs[indexParameters][35];
    const double * r_6 = & subs[indexParameters][36];
    const double * k_7 = & subs[indexParameters][37];
    const double * r_7 = & subs[indexParameters][38];
    //==========================================================================
    // Arguments
    Matrix<double,119, 1> args;
    double * nu_L1 = & args(0, 0);
    double * nu_12 = & args(1, 0);
    double * nu_23 = & args(2, 0);
    double * nu_34 = & args(3, 0);
    double * nu_45 = & args(4, 0);
    double * nu_56 = & args(5, 0);
    double * nu_67 = & args(6, 0);
    double * nu_R7 = & args(7, 0);
    double * Pi_y1 = & args(8, 0);
    double * Pi_y2 = & args(9, 0);
    double * Pi_y3 = & args(10, 0);
    double * Pi_y4 = & args(11, 0);
    double * Pi_y5 = & args(12, 0);
    double * Pi_y6 = & args(13, 0);
    double * Pi_y7 = & args(14, 0);
    double * V_1 = & args(15, 0);
    double * V_2 = & args(16, 0);
    double * V_3 = & args(17, 0);
    double * V_4 = & args(18, 0);
    double * V_5 = & args(19, 0);
    double * V_6 = & args(20, 0);
    double * V_7 = & args(21, 0);
    double * rho_1 = & args(22, 0);
    double * rho_2 = & args(23, 0);
    double * rho_3 = & args(24, 0);
    double * rho_4 = & args(25, 0);
    double * rho_5 = & args(26, 0);
    double * rho_6 = & args(27, 0);
    double * rho_7 = & args(28, 0);
    double * x_k1 = & args(29, 0);
    double * x_k2 = & args(30, 0);
    double * x_k3 = & args(31, 0);
    double * x_k4 = & args(32, 0);
    double * x_k5 = & args(33, 0);
    double * x_k6 = & args(34, 0);
    double * x_k7 = & args(35, 0);
    double * dnu_L1 = & args(36, 0);
    double * dnu_12 = & args(37, 0);
    double * dnu_23 = & args(38, 0);
    double * dnu_34 = & args(39, 0);
    double * dnu_45 = & args(40, 0);
    double * dnu_56 = & args(41, 0);
    double * dnu_67 = & args(42, 0);
    double * dnu_R7 = & args(43, 0);
    double * dPi_y1 = & args(44, 0);
    double * dPi_y2 = & args(45, 0);
    double * dPi_y3 = & args(46, 0);
    double * dPi_y4 = & args(47, 0);
    double * dPi_y5 = & args(48, 0);
    double * dPi_y6 = & args(49, 0);
    double * dPi_y7 = & args(50, 0);
    double * dV_1 = & args(51, 0);
    double * dV_2 = & args(52, 0);
    double * dV_3 = & args(53, 0);
    double * dV_4 = & args(54, 0);
    double * dV_5 = & args(55, 0);
    double * dV_6 = & args(56, 0);
    double * dV_7 = & args(57, 0);
    double * drho_1 = & args(58, 0);
    double * drho_2 = & args(59, 0);
    double * drho_3 = & args(60, 0);
    double * drho_4 = & args(61, 0);
    double * drho_5 = & args(62, 0);
    double * drho_6 = & args(63, 0);
    double * drho_7 = & args(64, 0);
    double * dx_k1 = & args(65, 0);
    double * dx_k2 = & args(66, 0);
    double * dx_k3 = & args(67, 0);
    double * dx_k4 = & args(68, 0);
    double * dx_k5 = & args(69, 0);
    double * dx_k6 = & args(70, 0);
    double * dx_k7 = & args(71, 0);
    double * v_k1 = & args(72, 0);
    double * v_k2 = & args(73, 0);
    double * v_k3 = & args(74, 0);
    double * v_k4 = & args(75, 0);
    double * v_k5 = & args(76, 0);
    double * v_k6 = & args(77, 0);
    double * v_k7 = & args(78, 0);
    double * q = & args(79, 0);
    double * Psi_L = & args(80, 0);
    double * v_m1 = & args(81, 0);
    double * v_m2 = & args(82, 0);
    double * v_m3 = & args(83, 0);
    double * v_m4 = & args(84, 0);
    double * v_m5 = & args(85, 0);
    double * v_m6 = & args(86, 0);
    double * v_m7 = & args(87, 0);
    double * mu_1 = & args(88, 0);
    double * mu_2 = & args(89, 0);
    double * mu_3 = & args(90, 0);
    double * mu_4 = & args(91, 0);
    double * mu_5 = & args(92, 0);
    double * mu_6 = & args(93, 0);
    double * mu_7 = & args(94, 0);
    double * mu_1_add_mu_2 = & args(95, 0);
    double * mu_2_add_mu_3 = & args(96, 0);
    double * mu_3_add_mu_4 = & args(97, 0);
    double * mu_4_add_mu_5 = & args(98, 0);
    double * mu_5_add_mu_6 = & args(99, 0);
    double * mu_6_add_mu_7 = & args(100, 0);
    double * mu_1minus_mu_2 = & args(101, 0);
    double * mu_2minus_mu_3 = & args(102, 0);
    double * mu_3minus_mu_4 = & args(103, 0);
    double * mu_4minus_mu_5 = & args(104, 0);
    double * mu_5minus_mu_6 = & args(105, 0);
    double * mu_6minus_mu_7 = & args(106, 0);
    double * RHS_1 = & args(107, 0);
    double * RHS_2 = & args(108, 0);
    double * RHS_3 = & args(109, 0);
    double * RHS_4 = & args(110, 0);
    double * RHS_5 = & args(111, 0);
    double * RHS_6 = & args(112, 0);
    double * Delta_12 = & args(113, 0);
    double * Delta_23 = & args(114, 0);
    double * Delta_34 = & args(115, 0);
    double * Delta_45 = & args(116, 0);
    double * Delta_56 = & args(117, 0);
    double * Delta_67 = & args(118, 0);
    //==========================================================================
    // Functions Results Definitions
    Matrix<double,31, 1> _ud_o;
    Matrix<double,44, 1> _Gnl;
    Matrix<double,44, 44> _jacGnlnl;
    Matrix<double,36, 1> _dxH;
    Matrix<double,8, 1> _z;
    Matrix<double,8, 1> _y;
    //==========================================================================
    // Functions Results Updates
    void ud_o_update();
    void Gnl_update();
    void jacGnlnl_update();
    void dxH_update();
    void z_update();
    void y_update();
    //==========================================================================
    // Operations Results Definition
    Matrix<double,36, 1> _ud_x;
    Matrix<double,44, 1> _Fnl;
    Matrix<double,44, 44> _jacFnl;
    Matrix<double,44, 44> _ijacFnl;
    Matrix<double,44, 1> _save_Fnl;
    double _res_Fnl;
    double _step_Fnl;
    Matrix<double,44, 1> _ud_vnl;
    //==========================================================================
    // Oprations Results Updates
    void ud_x_update();
    void Fnl_update();
    void jacFnl_update();
    void ijacFnl_update();
    void save_Fnl_update();
    void res_Fnl_update();
    void step_Fnl_update();
    void ud_vnl_update();
    //==========================================================================
    // Initialization
    void init();

    //==========================================================================
    // New functions for the LDL.T solve update
    SpMat A;
    void ud_o_init();
    void A_update();
    void A_init();
    void RHS_update();
    Matrix<double, 5, 1> delta;
    Matrix<double, 5, 1> RHS_vec;

    // Eigen::SimplicialCholesky <SpMat> solver;
    Eigen::BiCGSTAB<SparseMatrix<double> > solver;
    };


#endif /* VOCAL_TRACT_H */
