
// ==============================================================================
// 
// Copyright or © or Copr:
//     Antoine Falaize
// 
// Affiliation:
//     Team M2N (Mathematical and Numerical Methods),
//     Laboratoire des Sciences de l'Ingénieur pour l'Environnement (LaSIE),
//     UMR CNRS 7356, La Rochelle Université,
//     La Rochelle, France.
// 
// Contact:
//     antoine.falaize@univ-lr.fr
// 
// This file has been generated by the Python software PyPHS, which purpose
// is to model and simulate multiphysical systems in the Port-Hamiltonian
// formalism. See the website at the following url:
// "https://pyphs.github.io/pyphs/".
// 
// Created on:
//     2020/05/12 11:49:19
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// A copy of the GNU General Public License is available at the following url:
// "https://www.gnu.org/licenses/"
// 
// ==============================================================================

//==============================================================================
#include <iostream>
#include <vector>
#include <fstream>
#include <string>
#include <cstdio>
#include <time.h>
#include <math.h>
using namespace std;

#include <H5Cpp.h>
using namespace H5;

#include "core.h"

//==============================================================================
// Define timer object

class timer {
    private:
        unsigned long begTime;
    public:
        void start() {
            begTime = clock();
        }
        unsigned long elapsedTime() {
            return ((unsigned long) clock() - begTime) / CLOCKS_PER_SEC;
        }
        bool isTimeout(unsigned long seconds) {
            return seconds >= elapsedTime();
        }
};

//==============================================================================
// Main

int main() {

    //==========================================================================
    // Print start info

    cout << endl;
    cout << "=======================================" << endl;
    cout << endl;
    cout << "Start simulation of vocal_tract..." << endl;
    cout << endl;

    //==========================================================================
    // Number of time-steps to process

    const unsigned int nt = 250000;

    //==========================================================================
    // Define Progressbar refresh time
    const float refreshTime = 0.1;

    //==========================================================================
    // Initialize struct

    typedef struct argstruct{    
        double u[7];
        double x[31];
        double dx[31];
        double dxH[31];
        double w[7];
        double z[7];
        double y[7];
    } argstruct;
    argstruct mystruct;

    //==========================================================================
    // Open HDF5 file for reading inputs and storing results

    H5File h5fid;
    try{
        {
            h5fid = H5File("/home/victorw/ownCloud/IRCAM/03_DOCS/30_code_cpp_vocal_tract/vocalTractCpp/python/03_data/data/results.h5", H5F_ACC_RDWR);
        }
    }
    catch(FileIException error){
        {
            cerr << "Failed opening /home/victorw/ownCloud/IRCAM/03_DOCS/30_code_cpp_vocal_tract/vocalTractCpp/python/03_data/data/results.h5 file" << endl;
            exit(1);
        }
    }

    //==========================================================================
    // Initialize HDF5 objects for read/write

    const unsigned int h5rank = 2;
    hsize_t h5count[h5rank] = {1, 121};
    hsize_t h5offset[h5rank] = {0, 0};


    // Access global dataset, datatype and dataspace
    DataSet Gdataset = h5fid.openDataSet("global");
    DataType Gdatatype;
    Gdatatype.copy(Gdataset);
    DataSpace Gspace1 = Gdataset.getSpace();

    // Dataspace for single row
    DataSpace Gspace0 = DataSpace(h5rank, h5count, NULL);

    //==========================================================================
    // Instanciate a PHS C++ core object
    VOCAL_TRACT vocal_tract;

    //==========================================================================
    // ProgressBar data')
    int barWidth = 20;
    int ETA, ETAm, ETAs;
    float progress = 0.0;

    //==========================================================================
    // Process
    timer t;
    float t_temp = 0.0;
    t.start();

    for (unsigned int n = 0; n < nt; n++) {

        //======================================================================
        // Increment H5 offset

        h5offset[0] = n;

        //======================================================================
        // Define current row as dataspace selection

        Gspace1.selectHyperslab(H5S_SELECT_SET, h5count, h5offset, NULL, NULL);

        //======================================================================
        // Read row (to retrieve input and parameter data)

        Gdataset.read(&mystruct, Gdatatype, Gspace0, Gspace1);
        //======================================================================
        // Update controls
                
        vocal_tract.set_u((Matrix<double, 7, 1> &)mystruct.u);

        //======================================================================
        // Process update

        vocal_tract.update();

        //======================================================================
        // Update Results
                
        for (unsigned int ind=0; ind<31; ind++){
            mystruct.x[ind] = vocal_tract.x_vector()[ind];
        }
        for (unsigned int ind=0; ind<31; ind++){
            mystruct.dx[ind] = vocal_tract.dx_vector()[ind];
        }
        for (unsigned int ind=0; ind<31; ind++){
            mystruct.dxH[ind] = vocal_tract.dxH_vector()[ind];
        }
        for (unsigned int ind=0; ind<7; ind++){
            mystruct.w[ind] = vocal_tract.w_vector()[ind];
        }
        for (unsigned int ind=0; ind<7; ind++){
            mystruct.z[ind] = vocal_tract.z_vector()[ind];
        }
        for (unsigned int ind=0; ind<7; ind++){
            mystruct.y[ind] = vocal_tract.y_vector()[ind];
        }

        //======================================================================
        // Write back row (with updated data for x, y, w, z, dx, dxH)

        Gdataset.write(&mystruct, Gdatatype, Gspace0, Gspace1);

        //======================================================================
        // Progressbar

        if ((0) && ((t.elapsedTime() - t_temp > refreshTime) || (n == nt-1))){
            // Update progress for Progressbar
            progress = float(n+1)/float(nt);
            // Progressbar position
            unsigned int position = barWidth * progress;
            // Print Progressbar
            std::cout << "[";
            for (unsigned int i = 0; i < barWidth; ++i) {
                if (i < position) std::cout << "=";
                else if (i == position) std::cout << ">";
                else std::cout << " ";
            }
            // Estimated Time of Arrival
            ETA = (1./progress-1.)*(t.elapsedTime());
            // Estimated Time of Arrival in minutes
            ETAm = int(floor(ETA/60.));
            // Estimated Time of Arrival rest in seconds
            ETAs = floor(ETA%60);
            // Print Estimated Time of Arrival
            std::cout << "] " << int(progress * 100.0) << "% done, ETA: " << ETAm << "m" << ETAs << "s" << endl ;
            // Flush output
            std::cout.flush();
            t_temp = t.elapsedTime();
        }
    }

    //==========================================================================
    // Close h5file

    h5fid.close();

    //==========================================================================
    // Print path to data

    cout << endl;
    cout << "Results written in" << endl;
    cout << "/home/victorw/ownCloud/IRCAM/03_DOCS/30_code_cpp_vocal_tract/vocalTractCpp/python/03_data/data/results.h5"<< endl;
    cout << endl;

    //==========================================================================
    // Return

    return 0;
}
