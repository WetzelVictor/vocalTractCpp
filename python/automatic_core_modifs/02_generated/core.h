
// ==============================================================================
// 
// Copyright or © or Copr:
//     Antoine Falaize
// 
// Affiliation:
//     Team M2N (Mathematical and Numerical Methods),
//     Laboratoire des Sciences de l'Ingénieur pour l'Environnement (LaSIE),
//     UMR CNRS 7356, La Rochelle Université,
//     La Rochelle, France.
// 
// Contact:
//     antoine.falaize@univ-lr.fr
// 
// This file has been generated by the Python software PyPHS, which purpose
// is to model and simulate multiphysical systems in the Port-Hamiltonian
// formalism. See the website at the following url:
// "https://pyphs.github.io/pyphs/".
// 
// Created on:
//     2020/05/11 15:37:50
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// A copy of the GNU General Public License is available at the following url:
// "https://www.gnu.org/licenses/"
// 
// ==============================================================================

#ifndef VOCAL_TRACT_H
#define VOCAL_TRACT_H

#include <iostream>
#include <vector>
#include <cmath>
#include <Eigen/Dense>
#include "parameters.h"

// new include ++++
#include <Eigen/SparseCholesky>
#include <Eigen/Sparse>
typedef Eigen::SparseMatrix<double> SpMat; 


using namespace std;
using namespace Eigen;

class VOCAL_TRACT {
//==========================================================================
// PUBLIC    
    public:
    //==========================================================================
    // Sample Rate
    void set_sampleRate(float &);
    void set_sampleRate(double &);
    //==========================================================================
    // Core update
    void update();
    //==========================================================================
    // Acessors to Arguments, return vector<double>
    const vector<double> & x_vector() const;
    const vector<double> & dx_vector() const;
    const vector<double> & w_vector() const;
    const vector<double> & u_vector() const;
    const vector<double> & p_vector() const;
    const vector<double> & vnl_vector() const;
    const vector<double> & o_vector() const;
    //==========================================================================
    // Acessors to Arguments, return Matrix<double, n, m>
    const Matrix<double,21, 1> & x() const;
    const Matrix<double,21, 1> & dx() const;
    const Matrix<double,5, 1> & w() const;
    const Matrix<double,5, 1> & u() const;
    const Matrix<double,0, 0> & p() const;
    const Matrix<double,26, 1> & vnl() const;
    const Matrix<double,16, 1> & o() const;
    //==========================================================================
    // Mutators for Arguments, type = vector<double>
    void set_x(const vector<double> &);
    void set_dx(const vector<double> &);
    void set_w(const vector<double> &);
    void set_u(const vector<double> &);
    void set_p(const vector<double> &);
    void set_vnl(const vector<double> &);
    void set_o(const vector<double> &);
    //==========================================================================
    // Mutators for Arguments, type = Matrix<double, n, m>
    void set_x(const Matrix<double, 21, 1> &);
    void set_dx(const Matrix<double, 21, 1> &);
    void set_w(const Matrix<double, 5, 1> &);
    void set_u(const Matrix<double, 5, 1> &);
    void set_p(const Matrix<double, 0, 0> &);
    void set_vnl(const Matrix<double, 26, 1> &);
    void set_o(const Matrix<double, 16, 1> &);
    //==========================================================================
    // Mutators for a single argument, types are double with int index
    void set_x(const double &, unsigned int &);
    void set_dx(const double &, unsigned int &);
    void set_w(const double &, unsigned int &);
    void set_u(const double &, unsigned int &);
    void set_p(const double &, unsigned int &);
    void set_vnl(const double &, unsigned int &);
    void set_o(const double &, unsigned int &);
    //==========================================================================
    // Functions Results Accessors (matrix)
    const Matrix<double,16, 1> & ud_o() const;
    const Matrix<double,26, 1> & Gnl() const;
    const Matrix<double,26, 26> & jacGnlnl() const;
    const Matrix<double,21, 1> & dxH() const;
    const Matrix<double,5, 1> & z() const;
    const Matrix<double,5, 1> & y() const;
    //==========================================================================
    // Functions Results Accessors (vector)
    const vector<double> & ud_o_vector() const;
    const vector<double> & Gnl_vector() const;
    const vector<double> & jacGnlnl_vector() const;
    const vector<double> & dxH_vector() const;
    const vector<double> & z_vector() const;
    const vector<double> & y_vector() const;
    //==========================================================================
    // Functions Results Accessors (element)
    const double & ud_o(unsigned int &) const;
    const double & Gnl(unsigned int &) const;
    const double & jacGnlnl(unsigned int &) const;
    const double & dxH(unsigned int &) const;
    const double & z(unsigned int &) const;
    const double & y(unsigned int &) const;
    //==========================================================================
    // Oprations Results Accessors
    const Matrix<double,21, 1> & ud_x() const;
    const Matrix<double,26, 1> & Fnl() const;
    const Matrix<double,26, 26> & jacFnl() const;
    const Matrix<double,26, 26> & ijacFnl() const;
    const Matrix<double,26, 1> & save_Fnl() const;
    const double & res_Fnl() const;
    const double & step_Fnl() const;
    const Matrix<double,26, 1> & ud_vnl() const;
    //==========================================================================
    // Oprations Results Accessors
    vector<double> ud_x_vector() const;
    vector<double> Fnl_vector() const;
    vector<double> save_Fnl_vector() const;
    vector<double> ud_vnl_vector() const;
    //==========================================================================
    // Default Constructor
    VOCAL_TRACT();
    //==========================================================================
    // Default Destructor
    ~VOCAL_TRACT();

//==========================================================================
// PRIVATE    
    private:
    //==========================================================================
    // Sample Rate
    double sampleRate = 1000000.0;
    const double * F_S = & sampleRate;
    //==========================================================================
    // Parameters
    const unsigned int indexParameters = 0;  // See file "parameters.cpp".
    const double * P_0 = & subs[indexParameters][0];
    const double * rho_0 = & subs[indexParameters][1];
    const double * gamma = & subs[indexParameters][2];
    const double * Z_ray = & subs[indexParameters][3];
    const double * ell_1 = & subs[indexParameters][4];
    const double * L_1 = & subs[indexParameters][5];
    const double * V_0_1 = & subs[indexParameters][6];
    const double * ell_2 = & subs[indexParameters][7];
    const double * L_2 = & subs[indexParameters][8];
    const double * V_0_2 = & subs[indexParameters][9];
    const double * ell_3 = & subs[indexParameters][10];
    const double * L_3 = & subs[indexParameters][11];
    const double * V_0_3 = & subs[indexParameters][12];
    const double * ell_4 = & subs[indexParameters][13];
    const double * L_4 = & subs[indexParameters][14];
    const double * V_0_4 = & subs[indexParameters][15];
    const double * k_1 = & subs[indexParameters][16];
    const double * r_1 = & subs[indexParameters][17];
    const double * k_2 = & subs[indexParameters][18];
    const double * r_2 = & subs[indexParameters][19];
    const double * k_3 = & subs[indexParameters][20];
    const double * r_3 = & subs[indexParameters][21];
    const double * k_4 = & subs[indexParameters][22];
    const double * r_4 = & subs[indexParameters][23];
    //==========================================================================
    // Arguments
    Matrix<double,68, 1> args;
    double * nu_L1 = & args(0, 0);
    double * nu_12 = & args(1, 0);
    double * nu_23 = & args(2, 0);
    double * nu_34 = & args(3, 0);
    double * nu_R4 = & args(4, 0);
    double * Pi_y1 = & args(5, 0);
    double * Pi_y2 = & args(6, 0);
    double * Pi_y3 = & args(7, 0);
    double * Pi_y4 = & args(8, 0);
    double * V_1 = & args(9, 0);
    double * V_2 = & args(10, 0);
    double * V_3 = & args(11, 0);
    double * V_4 = & args(12, 0);
    double * rho_1 = & args(13, 0);
    double * rho_2 = & args(14, 0);
    double * rho_3 = & args(15, 0);
    double * rho_4 = & args(16, 0);
    double * x_k1 = & args(17, 0);
    double * x_k2 = & args(18, 0);
    double * x_k3 = & args(19, 0);
    double * x_k4 = & args(20, 0);
    double * dnu_L1 = & args(21, 0);
    double * dnu_12 = & args(22, 0);
    double * dnu_23 = & args(23, 0);
    double * dnu_34 = & args(24, 0);
    double * dnu_R4 = & args(25, 0);
    double * dPi_y1 = & args(26, 0);
    double * dPi_y2 = & args(27, 0);
    double * dPi_y3 = & args(28, 0);
    double * dPi_y4 = & args(29, 0);
    double * dV_1 = & args(30, 0);
    double * dV_2 = & args(31, 0);
    double * dV_3 = & args(32, 0);
    double * dV_4 = & args(33, 0);
    double * drho_1 = & args(34, 0);
    double * drho_2 = & args(35, 0);
    double * drho_3 = & args(36, 0);
    double * drho_4 = & args(37, 0);
    double * dx_k1 = & args(38, 0);
    double * dx_k2 = & args(39, 0);
    double * dx_k3 = & args(40, 0);
    double * dx_k4 = & args(41, 0);
    double * v_k1 = & args(42, 0);
    double * v_k2 = & args(43, 0);
    double * v_k3 = & args(44, 0);
    double * v_k4 = & args(45, 0);
    double * q = & args(46, 0);
    double * Psi_L = & args(47, 0);
    double * v_m1 = & args(48, 0);
    double * v_m2 = & args(49, 0);
    double * v_m3 = & args(50, 0);
    double * v_m4 = & args(51, 0);
    double * mu_1 = & args(52, 0);
    double * mu_2 = & args(53, 0);
    double * mu_3 = & args(54, 0);
    double * mu_4 = & args(55, 0);
    double * (mu_1_add_mu_2) = & args(56, 0);
    double * (mu_2_add_mu_3) = & args(57, 0);
    double * (mu_3_add_mu_4) = & args(58, 0);
    double * (mu_1minus_mu_2) = & args(59, 0);
    double * (mu_2minus_mu_3) = & args(60, 0);
    double * (mu_3minus_mu_4) = & args(61, 0);
    double * RHS_1 = & args(62, 0);
    double * RHS_2 = & args(63, 0);
    double * RHS_3 = & args(64, 0);
    double * Delta_12 = & args(65, 0);
    double * Delta_23 = & args(66, 0);
    double * Delta_34 = & args(67, 0);
    //==========================================================================
    // Functions Results Definitions
    Matrix<double,16, 1> _ud_o;
    Matrix<double,26, 1> _Gnl;
    Matrix<double,26, 26> _jacGnlnl;
    Matrix<double,21, 1> _dxH;
    Matrix<double,5, 1> _z;
    Matrix<double,5, 1> _y;
    //==========================================================================
    // Functions Results Updates
    void ud_o_update();
    void Gnl_update();
    void jacGnlnl_update();
    void dxH_update();
    void z_update();
    void y_update();
    //==========================================================================
    // Operations Results Definition
    Matrix<double,21, 1> _ud_x;
    Matrix<double,26, 1> _Fnl;
    Matrix<double,26, 26> _jacFnl;
    Matrix<double,26, 26> _ijacFnl;
    Matrix<double,26, 1> _save_Fnl;
    double _res_Fnl;
    double _step_Fnl;
    Matrix<double,26, 1> _ud_vnl;
    //==========================================================================
    // Oprations Results Updates
    void ud_x_update();
    void Fnl_update();
    void jacFnl_update();
    void ijacFnl_update();
    void save_Fnl_update();
    void res_Fnl_update();
    void step_Fnl_update();
    void ud_vnl_update();
    //==========================================================================
    // Initialization
    void init();

    //==========================================================================
    // New functions for the LDL.T solve update
    SpMat A;
    void ud_o_init();
    void A_update();
    void A_init();
    void RHS_update();
    Matrix<double, 5, 1> delta;
    Matrix<double, 5, 1> RHS_vec;

    Eigen::SimplicialCholesky <SpMat> solver;};

#endif /* VOCAL_TRACT_H */
